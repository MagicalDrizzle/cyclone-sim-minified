class NoiseChannel{constructor(i,e,s,t,a,n,l){this.octaves=i||4,this.falloff=e||.5,this.zoom=s||100,this.zZoom=t||this.zoom,this.xOff=a||0,this.yOff=n||0,this.zOff=l||0}get(i,e,s,t,a,n){return i=i||0,e=e||0,s=s||0,t=void 0!==t?t:this.xOff,a=void 0!==a?a:this.yOff,n=void 0!==n?n:this.zOff,noiseDetail(this.octaves,this.falloff),noise(i/this.zoom+t,e/this.zoom+a,s/this.zZoom+n)}}class EnvNoiseChannel extends NoiseChannel{constructor(i,e,s,t,a,n,l,o,r,h,f){let d=NC_OFFSET_RANDOM_FACTOR;super(a,n,l,o,random(d),random(d),random(d)),this.wobbleMax=r||1,this.zWobbleMax=h||this.wobbleMax,this.wobbleRotFactor=f||PI/16,this.wobbleVector=p5.Vector.random2D(),this.basin=i instanceof Basin&&i,this.field=e,this.index=s,t instanceof LoadData&&this.load(t)}get(i,e,s){let t=this.fetchOffsets(s);if(!t)throw ENVDATA_NOT_FOUND_ERROR;let{xo:a,yo:n,zo:l}=t;return super.get(i,e,s,a,n,l)}fetchOffsets(i){let e=this.basin;if(i>=e.tick)return{xo:this.xOff,yo:this.yOff,zo:this.zOff};{i=floor(i/ADVISORY_TICKS)*ADVISORY_TICKS;let s=e.getSeason(i);i=(i-e.seasonTick(s))/ADVISORY_TICKS;let t=e.fetchSeason(s);if(t&&t.envData&&t.envData[this.field]&&t.envData[this.field][this.index]){i-=t.envRecordStarts;let e=t.envData[this.field][this.index][i];return{xo:e.x,yo:e.y,zo:e.z}}}}wobble(){let i=this.wobbleVector;i.setMag(random(1e-4,this.wobbleMax)),this.xOff+=i.x/this.zoom,this.yOff+=i.y/this.zoom,this.zOff+=random(-this.zWobbleMax,this.zWobbleMax)/this.zZoom,i.rotate(random(-this.wobbleRotFactor,this.wobbleRotFactor))}record(){let i,e=this.basin,s=e.fetchSeason(-1,!0,!0),t=s;t.envData||(t.envData={},i=!0),(t=t.envData)[this.field]||(t[this.field]={},i=!0),(t=t[this.field])[this.index]||(t[this.index]=[],i=!0),t=t[this.index],i&&(s.envRecordStarts=floor(e.tick/ADVISORY_TICKS)-e.seasonTick()/ADVISORY_TICKS),t.push({x:this.xOff,y:this.yOff,z:this.zOff}),s.modified=!0}save(){let i={},e=i.wobbleVector={};e.x=this.wobbleVector.x,e.y=this.wobbleVector.y;for(let e of["xOff","yOff","zOff"])i[e]=this[e];return i}load(i){if(i instanceof LoadData){let e,s;if(i.format>=FORMAT_WITH_INDEXEDDB){let t=i.value;for(let i of["xOff","yOff","zOff"])t[i]&&(this[i]=t[i]);e=t.wobbleVector&&t.wobbleVector.x,s=t.wobbleVector&&t.wobbleVector.y}else{let t=i.value,a=decodeB36StringArray(t);this.xOff=a.pop()||this.xOff,this.yOff=a.pop()||this.yOff,this.zOff=a.pop()||this.zOff,e=a.pop(),s=a.pop()}void 0!==e&&void 0!==s&&(this.wobbleVector=createVector(e,s))}}}class EnvField{constructor(i,e,s,t){this.basin=i instanceof Basin&&i,this.name=e,this.noise=[],this.accurateAfter=-1,this.version=t.version,s instanceof LoadData&&(s.value.version!==this.version?this.accurateAfter=this.basin.tick:this.accurateAfter=s.value.accurateAfter),this.isVectorField=t.vector,this.noVectorFlip=t.noVectorFlip,this.noWobble=t.noWobble,this.hueMap=t.hueMap||[0,1,0,300],this.magMap=t.magMap||[0,1,0,10],this.invisible=t.invisible,this.oceanic=t.oceanic,this.modifiers=t.modifiers,this.isVectorField&&(this.vec=createVector()),t.mapFunc instanceof Function&&(this.mapFunc=t.mapFunc);let a=null;if(t.noiseChannels instanceof Array){let i=t.noiseChannels;for(let e=0;e<i.length;e++)if(i[e]instanceof Array||""===i[e]&&a instanceof Array){let t;s instanceof LoadData&&(t=s.value.noiseData[e],t=s.sub(t)),i[e]instanceof Array&&(a=i[e]);let n=new EnvNoiseChannel(this.basin,this.name,e,t,...a);this.noise.push(n)}}}get(i,e,s,t){try{if(t||(e=this.basin.hemY(e)),this.mapFunc){let t={};t.noise=((t,a,n,l)=>(void 0===a&&(a=i),void 0===n&&(n=e),void 0===l&&(l=s),this.noise[t].get(a,n,l))),t.basin=this.basin,t.field=((t,a,n,l)=>(void 0===a&&(a=i),void 0===n&&(n=e),void 0===l&&(l=s),this.basin.env.fields[t].accurateAfter>this.accurateAfter&&(this.accurateAfter=this.basin.env.fields[t].accurateAfter),this.basin.env.get(t,a,n,l,!0))),t.yearfrac=(i=>i%YEAR_LENGTH/YEAR_LENGTH),t.piecewise=((i,e)=>{let s=12*i,t=[e[e.length-1][0]-12,e[e.length-1][1]];for(let i of e){if(s<i[0])return map(s,t[0],i[0],t[1],i[1]);t=i}return map(s,t[0],e[0][0]+12,t[1],e[0][1])}),t.vec=this.vec,t.modifiers=this.modifiers||{};let a=this.mapFunc(t,i,e,s);return this.isVectorField&&!this.noVectorFlip&&(a.y=this.basin.hem(a.y)),a}return this.isVectorField?(this.vec.set(1),this.vec.rotate(map(this.noise[0].get(i,e,s),0,1,0,4*TAU)),this.noVectorFlip||(this.vec.y=this.basin.hem(this.vec.y)),this.vec):this.noise[0].get(i,e,s)}catch(i){if(!t&&i===ENVDATA_NOT_FOUND_ERROR)return null;throw i}}wobble(){if(!this.noWobble)for(let i=0;i<this.noise.length;i++)this.noise[i].wobble()}render(){envLayer.noFill();let i=ceil(ENV_LAYER_TILE_SIZE*scaler);for(let e=0;e<WIDTH;e+=ENV_LAYER_TILE_SIZE)for(let s=0;s<HEIGHT;s+=ENV_LAYER_TILE_SIZE){let t=e+ENV_LAYER_TILE_SIZE/2,a=s+ENV_LAYER_TILE_SIZE/2;if(!this.oceanic||land.tileContainsOcean(t,a)){let n=this.get(t,a,viewTick);if(this.isVectorField){if(envLayer.push(),envLayer.stroke(0),envLayer.scale(scaler),envLayer.translate(t,a),null!==n){envLayer.rotate(n.heading());let i=n.mag(),e=this.magMap,s=map(i,e[0],e[1],e[2],e[3]);envLayer.line(0,0,s,0),envLayer.noStroke(),envLayer.fill(0),envLayer.triangle(s+5,0,s,3,s,-3)}else envLayer.line(-3,-3,3,3),envLayer.line(-3,3,3,-3);envLayer.pop()}else{if(null!==n){let i=this.hueMap;i instanceof Function?envLayer.fill(i(n)):envLayer.fill(map(n,i[0],i[1],i[2],i[3]),100,100)}else envLayer.fill(0,0,50);envLayer.rect(e*scaler,s*scaler,i,i),null===n&&(envLayer.fill(0,0,60),envLayer.triangle(e*scaler,s*scaler,e*scaler+i,s*scaler,e*scaler,s*scaler+i))}}}simSettings.showMagGlass&&this.renderMagGlass()}renderMagGlass(){let i=getMouseX(),e=getMouseY();magnifyingGlass.noFill();let s=this.get(i,e,viewTick);if(this.isVectorField){if(coordinateInCanvas(i,e)&&(!this.oceanic||land.tileContainsOcean(i,e)&&!land.get(i,e))){let i=s;magnifyingGlass.push(),magnifyingGlass.stroke(0),magnifyingGlass.scale(scaler);let e=buffers.get(magnifyingGlass);if(magnifyingGlass.translate(e.baseWidth/2,e.baseHeight/2),null!==i){magnifyingGlass.rotate(i.heading());let e=i.mag(),s=this.magMap,t=map(e,s[0],s[1],s[2],s[3]);magnifyingGlass.line(0,0,t,0),magnifyingGlass.noStroke(),magnifyingGlass.fill(0),magnifyingGlass.triangle(t+5,0,t,3,t,-3)}else magnifyingGlass.line(-3,-3,3,3),magnifyingGlass.line(-3,3,3,-3);magnifyingGlass.pop()}}else if(null!==s)for(let s=floor(magnifyingGlass.width/4);s<3*magnifyingGlass.width/4;s++)for(let t=floor(magnifyingGlass.height/4);t<3*magnifyingGlass.height/4;t++){let a=s-magnifyingGlass.width/2,n=t-magnifyingGlass.height/2;if(sqrt(sq(a)+sq(n))<magnifyingGlass.width/4){let l=i+a/scaler,o=e+n/scaler;if(coordinateInCanvas(l,o)&&(!this.oceanic||land.tileContainsOcean(l,o)&&!land.get(l,o))){let i=this.get(l,o,viewTick);if(null!==i){let e=this.hueMap;e instanceof Function?magnifyingGlass.fill(e(i)):magnifyingGlass.fill(map(i,e[0],e[1],e[2],e[3]),100,100)}else magnifyingGlass.fill(0,0,50);magnifyingGlass.rect(s,t,1,1)}}}else magnifyingGlass.fill(0,0,50),magnifyingGlass.ellipse(magnifyingGlass.width/2,magnifyingGlass.height/2,magnifyingGlass.width,magnifyingGlass.height)}record(){if(!this.noWobble)for(let i=0;i<this.noise.length;i++)this.noise[i].record()}}class Environment{constructor(i){this.basin=i instanceof Basin&&i,this.fields={},this.fieldList=[],this.displaying=-1,this.layerIsOceanic=!1,this.layerIsVector=!1}addField(i,...e){this.fields[i]=new EnvField(this.basin,i,...e),this.fieldList.push(i)}wobble(){for(let i in this.fields)this.fields[i].wobble()}record(){for(let i in this.fields)this.fields[i].record()}get(i,e,s,t,a){return this.fields[i].get(e,s,t,a)}displayLayer(){envLayer.clear(),magnifyingGlass.clear(),this.displaying>=0&&this.fields[this.fieldList[this.displaying]].render()}displayNext(){do{this.displaying++}while(this.displaying<this.fieldList.length&&this.fields[this.fieldList[this.displaying]].invisible);this.displaying>=this.fieldList.length?this.displaying=-1:(this.layerIsOceanic=this.fields[this.fieldList[this.displaying]].oceanic,this.layerIsVector=this.fields[this.fieldList[this.displaying]].isVectorField),this.displayLayer()}updateMagGlass(){magnifyingGlass.clear(),simSettings.showMagGlass&&this.displaying>=0&&this.fields[this.fieldList[this.displaying]].renderMagGlass()}init(i){if(i instanceof LoadData&&i.format<FORMAT_WITH_IMPROVED_ENV){let e={},s=i.value,t=(...i)=>({version:0,accurateAfter:-1,noiseData:i});e.jetstream=t(s[8]),e.LLSteering=t(s[7],s[6],s[5],s[4]),e.ULSteering=t(s[3],s[2]),e.shear=t(),e.SSTAnomaly=t(s[1]),e.SST=t(),e.moisture=t(s[0]),i=i.sub(e)}for(let e in ENV_DEFS[this.basin.actMode]){let s={modifiers:{}};if(ENV_DEFS.defaults[e]){let i=ENV_DEFS.defaults[e];for(let e in i)if("modifiers"===e)for(let e in i.modifiers)s.modifiers[e]=i.modifiers[e];else s[e]=i[e]}let t=ENV_DEFS[this.basin.actMode][e];for(let i in t)if("modifiers"===i)for(let i in t.modifiers)s.modifiers[i]=t.modifiers[i];else s[i]=t[i];let a=i instanceof LoadData&&i.sub(i.value[e]);this.addField(e,a,s)}}}class Land{constructor(i){this.basin=i instanceof Basin&&i,this.noise=new NoiseChannel(9,.5,100),this.map=[],this.oceanTile=[],this.mapDefinition=void 0,this.drawn=!1,this.snowDrawn=!1,this.shaderDrawn=!1,this.calculate()}get(i,e){let s=this.mapDefinition;if(i=floor(i*s),e=floor(e*s),this.map[i]&&this.map[i][e]){let s=this.map[i][e].val;return s>.5?s:0}return 0}getSubBasin(i,e){let s=this.mapDefinition;return i=floor(i*s),e=floor(e*s),this.map[i]&&this.map[i][e]?this.map[i][e].subBasin:0}inBasin(i,e){let s=this.getSubBasin(i,e);return this.basin.subInBasin(s)}calculate(){let i,e,s,t,a,n=MAP_TYPES[this.basin.mapType];if("pixelmap"===n.form){let n=this.basin.mapImg;i=n.width,e=n.height,a=this.mapDefinition=i/WIDTH,t=n._pixelDensity,s=n.pixels}else i=WIDTH*MAP_DEFINITION,e=HEIGHT*MAP_DEFINITION,a=this.mapDefinition=MAP_DEFINITION;for(let l=0;l<i;l++){this.map[l]=[];for(let o=0;o<e;o++){let e=this.map[l][o]={},r=l/a,h=o/a;if("pixelmap"===n.form){let a=4*(o*i*sq(t)+l*t),n=s[a];e.val=map(n,0,255,0,1),e.subBasin=s[a+1]}else{let i,s=this.noise.get(r,h),t=n.landBiasFactors;if("linear"==n.form){let e=WIDTH*t[0];i=r<e?map(r,0,e,t[1],t[2]):map(r-e,0,WIDTH-e,t[2],t[3])}else if("radial"==n.form){let e=WIDTH*t[0],s=HEIGHT*t[1],a=sqrt(sq(r-e)+sq(h-s)),n=t[2]*sqrt(WIDTH*HEIGHT),l=t[3]*sqrt(WIDTH*HEIGHT);i=a<n?map(a,0,n,t[4],t[5]):a<l?map(a,n,l,t[5],t[6]):t[6]}e.val=s+i,e.subBasin=0}let f=floor(r/ENV_LAYER_TILE_SIZE),d=floor(h/ENV_LAYER_TILE_SIZE);this.oceanTile[f]||(this.oceanTile[f]=[]),e.val<=.5&&(this.oceanTile[f][d]=!0)}}}*draw(){yield"Rendering land...";let{fullW:i,fullH:e}=fullDimensions(),s=i/WIDTH,t=(i,e)=>this.get(i/s,e/s),a=(i,e)=>this.inBasin(i/s,e/s);for(let s=0;s<i;s++)for(let n=0;n<e;n++){let l=t(s,n);if(l){for(let i=0;i<COLORS.land.length;i++)if(l>COLORS.land[i][0]){let e=COLORS.land[i][1];if(simSettings.smoothLandColor&&i>0){let s=COLORS.land[i-1][1],t=map(l,COLORS.land[i][0],COLORS.land[i-1][0],0,1);landBuffer.fill(lerpColor(e,s,t))}else landBuffer.fill(e);landBuffer.rect(s,n,1,1);break}let a=!1;s>0&&!t(s-1,n)&&(a=!0),n>0&&!t(s,n-1)&&(a=!0),s<i-1&&!t(s+1,n)&&(a=!0),n<e-1&&!t(s,n+1)&&(a=!0),a&&coastLine.rect(s,n,1,1)}else a(s,n)||outBasinBuffer.rect(s,n,1,1)}simSettings.snowLayers&&!this.snowDrawn&&(yield*this.drawSnow()),simSettings.useShader&&!this.shaderDrawn&&(yield*this.drawShader()),this.drawn=!0}*drawSnow(){yield"Rendering "+(random()<.02?"sneaux":"snow")+"...";let i=deviceOrientation===PORTRAIT?displayHeight:displayWidth,e=i*HEIGHT/WIDTH,s=i/WIDTH,t=(i,e)=>this.get(i/s,e/s),a=10*simSettings.snowLayers;for(let n=0;n<i;n++)for(let i=0;i<e;i++){let e=t(n,i);if(e){let t=1-this.basin.hemY(i/s)/HEIGHT,l=.95-e,o=t>0?ceil(map(l/t,.15,.45,0,a)):l<0?0:a;for(let e=max(o,0);e<a;e++)snow[e].rect(n,i,1,1)}}this.snowDrawn=!0}*drawShader(){yield"Rendering shader...";let i=deviceOrientation===PORTRAIT?displayHeight:displayWidth,e=i*HEIGHT/WIDTH,s=i/WIDTH,t=(i,e)=>this.get(i/s,e/s);for(let s=0;s<i;s++)for(let i=0;i<e;i++){let e=t(s,i);0===e&&(e=.5);let a=0;for(let n=1;n<6;n++){let l=t(s-n,i-n)-e-8e-4*n;(l=constrain(map(l,0,.14,0,191),0,191))>a&&(a=l)}a>0&&(landShader.fill(0,a),landShader.rect(s,i,1,1))}this.shaderDrawn=!0}tileContainsOcean(i,e){return i=floor(i/ENV_LAYER_TILE_SIZE),e=floor(e/ENV_LAYER_TILE_SIZE),this.oceanTile[i][e]}clearSnow(){for(let i=0;i<MAX_SNOW_LAYERS;i++)snow[i].clear();this.snowDrawn=!1}clear(){landBuffer.clear(),outBasinBuffer.clear(),coastLine.clear(),landShader.clear(),this.clearSnow(),this.drawn=!1,this.shaderDrawn=!1}}function seasonalSine(i,e){return e=void 0===e?2.4:e,sin(TAU*(i-YEAR_LENGTH*e)/YEAR_LENGTH)}